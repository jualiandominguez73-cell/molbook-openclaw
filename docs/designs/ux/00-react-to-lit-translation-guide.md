# React to Lit Translation Guide for Clawdbrain Automations UI

## Overview

This guide provides detailed, explicit instructions for translating React-based UI prototypes (generated by Magic MCP) to Lit Web Components that match Clawdbrain's existing patterns and conventions.

## Critical Context: Clawdbrain's UI Stack

**Framework:** Lit 3.3.2 (NOT React)
**Styling:** Tailwind CSS v4 with PostCSS
**Icon System:** Custom `icon()` function from `ui/src/ui/icons.ts`
**Component Pattern:** Functional render functions + state management via controllers
**Navigation:** Hash-based routing via `ui/src/ui/navigation.ts`
**Toast System:** Global `toast()` function from `ui/src/ui/components/toast.ts`
**Command Palette:** `renderCommandPalette()` function from `ui/src/ui/components/command-palette.ts`

---

## Table of Contents

1. [Core Framework Differences](#1-core-framework-differences)
2. [Component Structure](#2-component-structure)
3. [State Management](#3-state-management)
4. [Props and Properties](#4-props-and-properties)
5. [Event Handling](#5-event-handling)
6. [Styling](#6-styling)
7. [Lifecycle Methods](#7-lifecycle-methods)
8. [Conditionals and Rendering](#8-conditionals-and-rendering)
9. [Lists and Iteration](#9-lists-and-iteration)
10. [Forms and Inputs](#10-forms-and-inputs)
11. [Icons](#11-icons)
12. [Toasts and Notifications](#12-toasts-and-notifications)
13. [Modals and Dialogs](#13-modals-and-dialogs)
14. [Navigation and Routing](#14-navigation-and-routing)
15. [Common Translation Patterns](#15-common-translation-patterns)
16. [Clawdbrain-Specific Patterns](#16-clawdbrain-specific-patterns)
17. [Complete Translation Example](#17-complete-translation-example)

---

## 1. Core Framework Differences

### React

- JSX-based syntax
- Virtual DOM
- Hooks (useState, useEffect, etc.)
- Component = function or class
- Props passed as function arguments

### Lit

- Template literals with `html` tag function
- No virtual DOM (direct DOM manipulation)
- Decorators (@customElement, @state, @property)
- Component = class extending LitElement
- Properties as class properties with decorators

### Key Insight

**Clawdbrain uses a hybrid pattern:** Components are often render FUNCTIONS that return Lit templates, while state is managed in CONTROLLER classes. This is different from pure React OR pure Lit.

---

## 2. Component Structure

### React Component

```tsx
import { useState } from "react";

interface AutomationCardProps {
  automation: Automation;
  onEdit: (id: string) => void;
}

export function AutomationCard({ automation, onEdit }: AutomationCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div className="automation-card">
      <h3>{automation.name}</h3>
      <button onClick={() => onEdit(automation.id)}>Edit</button>
    </div>
  );
}
```

### Lit Component (Class-Based - Standard Lit Pattern)

```typescript
import { LitElement, html, css } from "lit";
import { customElement, state, property } from "lit/decorators.js";
import { icon } from "../icons";

export interface Automation {
  id: string;
  name: string;
}

@customElement("automation-card")
export class AutomationCard extends LitElement {
  static styles = css`
    :host {
      display: block;
    }
    .automation-card {
      padding: 1rem;
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
    }
  `;

  @property({ attribute: false }) automation!: Automation;
  @property({ attribute: false }) onEdit!: (id: string) => void;

  @state() private isExpanded = false;

  render() {
    return html`
      <div class="automation-card">
        <h3>${this.automation.name}</h3>
        <button @click=${() => this.onEdit(this.automation.id)}>Edit</button>
      </div>
    `;
  }
}
```

### Lit Render Function (Clawdbrain Pattern - PREFERRED)

```typescript
import { html, nothing } from "lit";
import { icon, type IconName } from "../icons";

export interface Automation {
  id: string;
  name: string;
  status: "active" | "suspended" | "error";
}

export interface AutomationCardProps {
  automation: Automation;
  onEdit: (id: string) => void;
  isExpanded?: boolean;
}

export function renderAutomationCard(props: AutomationCardProps) {
  const { automation, onEdit, isExpanded = false } = props;

  return html`
    <div class="automation-card">
      <div class="automation-card__header">
        <h3 class="automation-card__name">${automation.name}</h3>
        <button class="automation-card__edit-btn" @click=${() => onEdit(automation.id)}>
          ${icon("edit", { size: 16 })} Edit
        </button>
      </div>
      ${isExpanded
        ? html`
            <div class="automation-card__details">
              <p>Status: ${automation.status}</p>
            </div>
          `
        : nothing}
    </div>
  `;
}
```

**IMPORTANT:** For Clawdbrain automations UI, prefer the **render function pattern** over class-based Lit components. This matches existing Clawdbrain patterns.

---

## 3. State Management

### React useState

```tsx
const [count, setCount] = useState(0);
const [name, setName] = useState("");
const [items, setItems] = useState<string[]>([]);
```

### Lit @state Decorator (Class-Based)

```typescript
@state() private count = 0;
@state() private name = "";
@state() private items: string[] = [];
```

### Controller State (Clawdbrain Pattern - PREFERRED)

```typescript
// In controller file (e.g., ui/src/ui/controllers/automations.ts)
export type AutomationsState = {
  automations: Automation[];
  loading: boolean;
  error: string | null;
  selectedId: string | null;
};

export const automationsState: AutomationsState = {
  automations: [],
  loading: false,
  error: null,
  selectedId: null,
};

// In render function, read from state:
export function renderAutomationsList(state: AutomationsState) {
  if (state.loading) {
    return html`<div class="loading">Loading...</div>`;
  }
  return html` <div class="automations-list">${state.automations.map(renderAutomationCard)}</div> `;
}
```

### React setState with Updates

```tsx
setItems((prev) => [...prev, newItem]);
setCount((prev) => prev + 1);
```

### Lit State Updates

```typescript
this.items = [...this.items, newItem];
this.count++;
```

### Controller State Updates

```typescript
// In controller function:
async function loadAutomations(state: AutomationsState) {
  state.loading = true;
  try {
    const result = await client.request("automations.list");
    state.automations = result.automations;
  } catch (err) {
    state.error = String(err);
  } finally {
    state.loading = false;
  }
}
```

---

## 4. Props and Properties

### React Props

```tsx
interface Props {
  title: string;
  count?: number;
  onAction: () => void;
  items: Item[];
}

function MyComponent({ title, count = 0, onAction, items }: Props) {
  return (
    <div>
      {title}: {count}
    </div>
  );
}
```

### Lit @property Decorator (Class-Based)

```typescript
@property() title!: string;
@property({ type: Number }) count = 0;
@property({ attribute: false }) onAction!: () => void;
@property({ attribute: false }) items!: Item[];
```

### Render Function Props (Clawdbrain Pattern)

```typescript
interface MyComponentProps {
  title: string;
  count?: number;
  onAction: () => void;
  items: Item[];
}

export function renderMyComponent(props: MyComponentProps) {
  const { title, count = 0, onAction, items } = props;
  return html`<div>${title}: ${count}</div>`;
}
```

### Property Types in Lit

```typescript
@property() // String (default)
@property({ type: Number }) count: number = 0;
@property({ type: Boolean }) disabled: boolean = false;
@property({ type: Array }) items: Item[] = [];
@property({ type: Object }) config: Config = {};
@property({ attribute: false }) // Not reflected to attribute (for functions/objects)
```

---

## 5. Event Handling

### React Event Handlers

```tsx
<button onClick={handleClick}>Click</button>
<input onChange={handleChange} />
<div onMouseEnter={handleMouseEnter} />
<form onSubmit={handleSubmit}>
```

### Lit Event Handlers

```typescript
<button @click=${handleClick}>Click</button>
<input @input=${handleChange} />
<div @mouseenter=${handleMouseEnter} />
<form @submit=${handleSubmit}>
```

### Event Handler Differences

#### React

```tsx
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  e.preventDefault();
  console.log(e.currentTarget.value);
};
```

#### Lit

```typescript
const handleClick = (e: Event) => {
  e.preventDefault();
  const target = e.currentTarget as HTMLButtonElement;
  console.log(target.value);
};
```

### Passing Arguments to Event Handlers

#### React

```tsx
<button onClick={() => onEdit(item.id)}>Edit</button>
<button onClick={handleClick.bind(null, item.id)}>Edit</button>
```

#### Lit

```typescript
<button @click=${() => onEdit(item.id)}>Edit</button>
<!-- Arrow functions work the same way in Lit -->
```

### Input Handling

#### React

```tsx
const [value, setValue] = useState("");

<input value={value} onChange={(e) => setValue(e.target.value)} />;
```

#### Lit

```typescript
// Class-based
@property() value = "";

render() {
  return html`
    <input
      .value=${this.value}
      @input=${(e: Event) => {
        this.value = (e.target as HTMLInputElement).value;
      }}
    />
  `;
}

// Render function pattern (with state in controller)
export function renderInput(props: {
  value: string;
  onInput: (value: string) => void;
}) {
  return html`
    <input
      .value=${props.value}
      @input=${(e: Event) => {
        props.onInput((e.target as HTMLInputElement).value);
      }}
    />
  `;
}
```

**IMPORTANT:** Use `.value=${}` (property binding) instead of `value="${}"` (attribute binding) for input values in Lit.

---

## 6. Styling

### React Styling Options

#### Inline Styles

```tsx
<div style={{ display: "flex", gap: "1rem" }}>Content</div>
```

#### CSS Modules

```tsx
import styles from "./Component.module.css";
<div className={styles.container}>Content</div>;
```

#### Tailwind

```tsx
<div className="flex gap-4 p-4 bg-white rounded-lg">Content</div>
```

### Lit Styling

#### Static Styles (Class-Based Components)

```typescript
@customElement("my-component")
export class MyComponent extends LitElement {
  static styles = css`
    :host {
      display: block;
    }

    .container {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      background: var(--panel-strong);
      border-radius: var(--radius-lg);
    }

    .container:hover {
      background: var(--panel-hover);
    }
  `;

  render() {
    return html`<div class="container">Content</div>`;
  }
}
```

#### Using Tailwind (Clawdbrain Pattern)

```typescript
// In render function - just use Tailwind classes directly
export function renderAutomationCard(props: AutomationCardProps) {
  return html`
    <div class="automation-card flex gap-4 p-4 bg-white rounded-lg border">Content</div>
  `;
}
```

#### Clawdbrain CSS Custom Properties

```typescript
// Common variables used in Clawdbrain:
// - var(--panel-strong) - Strong panel background
// - var(--panel-hover) - Hover state background
// - var(--border) - Border color
// - var(--radius-lg) - Large border radius (0.75rem)
// - var(--radius-sm) - Small border radius (0.375rem)
// - var(--text) - Primary text color
// - var(--muted) - Secondary text color
// - var(--ok) - Success color
// - var(--warn) - Warning color
// - var(--danger) - Error color
// - var(--accent) - Accent color
// - var(--shadow-elevated-lg) - Large shadow
```

#### Style Tag in Render (For dynamic styles)

```typescript
export function renderComponent(props: { color: string }) {
  return html`
    <style>
      .dynamic-style {
        color: ${props.color};
      }
    </style>
    <div class="dynamic-style">Content</div>
  `;
}
```

---

## 7. Lifecycle Methods

### React Effects

```tsx
useEffect(() => {
  // On mount
  fetchData();

  return () => {
    // On unmount
    cleanup();
  };
}, [dependency]);

useEffect(() => {
  // On every render
  console.log("Rendered");
});
```

### Lit Lifecycle (Class-Based)

```typescript
connectedCallback() {
  super.connectedCallback();
  // On mount
  this.fetchData();
}

disconnectedCallback() {
  // On unmount
  this.cleanup();
  super.disconnectedCallback();
}

willUpdate(changedProperties: Map<PropertyKey, unknown>) {
  // Before update, when properties change
  if (changedProperties.has('automationId')) {
    this.fetchAutomation();
  }
}

updated(changedProperties: Map<PropertyKey, unknown>) {
  // After update
  if (changedProperties.has('value')) {
    this.dispatchValueChange();
  }
}
```

### Controller Pattern (Clawdbrain)

```typescript
// No lifecycle - just call functions when needed
export async function initAutomationsController(state: AutomationsState) {
  // Setup
  await loadAutomations(state);
}

// Call from app initialization or view change
```

---

## 8. Conditionals and Rendering

### React Conditionals

#### Ternary

```tsx
{
  isLoggedIn ? <Dashboard /> : <Login />;
}
```

#### Logical AND

```tsx
{
  showDetails && <DetailsPanel />;
}
```

#### Early Return

```tsx
if (loading) return <Loading />;
if (error) return <Error />;
return <Content />;
```

### Lit Conditionals

#### Ternary

```typescript
isLoggedIn ? html`<dashboard-view></dashboard-view>` : html`<login-view></login-view>`;
```

#### Logical AND (use nothing for false)

```typescript
showDetails ? html`<details-panel></details-panel>` : nothing;
// or
html`${showDetails ? html`<details-panel></details-panel>` : nothing}`;
```

#### Early Return

```typescript
export function renderView(props: ViewProps) {
  if (props.loading) {
    return html`<loading-indicator></loading-indicator>`;
  }
  if (props.error) {
    return html`<error-message .message=${props.error}></error-message>`;
  }
  return html`<content-view></content-view>`;
}
```

#### Using `nothing` from Lit

```typescript
import { html, nothing } from "lit";

// Conditional attribute
<div class=${props.active ? "active" : nothing}>Content</div>

// Conditional content
${props.showHeader ? html`<header>Header</header>` : nothing}
```

---

## 9. Lists and Iteration

### React Lists

```tsx
{
  items.map((item) => (
    <div key={item.id} className="item">
      {item.name}
    </div>
  ));
}
```

### Lit Lists

```typescript
${items.map(item => html`
  <div class="item" data-id="${item.id}">
    ${item.name}
  </div>
`)}
```

### With Index

```tsx
{
  items.map((item, index) => <div key={index}>{item.name}</div>);
}
```

```typescript
${items.map((item, index) => html`
  <div data-index="${index}">${item.name}</div>
`)}
```

### Nested Lists

```tsx
{
  groups.map((group) => (
    <div key={group.id}>
      <h3>{group.name}</h3>
      {group.items.map((item) => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  ));
}
```

```typescript
${groups.map(group => html`
  <div data-group="${group.id}">
    <h3>${group.name}</h3>
    ${group.items.map(item => html`
      <div data-item="${item.id}">${item.name}</div>
    `)}
  </div>
`)}
```

---

## 10. Forms and Inputs

### React Form State

```tsx
const [formData, setFormData] = useState({
  name: "",
  email: "",
  subscribed: false,
  category: "general",
});

const handleChange = (field: string, value: any) => {
  setFormData((prev) => ({ ...prev, [field]: value }));
};

return (
  <form onSubmit={handleSubmit}>
    <input value={formData.name} onChange={(e) => handleChange("name", e.target.value)} />
    <input
      type="checkbox"
      checked={formData.subscribed}
      onChange={(e) => handleChange("subscribed", e.target.checked)}
    />
    <select value={formData.category} onChange={(e) => handleChange("category", e.target.value)}>
      <option value="general">General</option>
      <option value="news">News</option>
    </select>
  </form>
);
```

### Lit Form State (Render Function Pattern)

```typescript
export interface FormState {
  name: string;
  email: string;
  subscribed: boolean;
  category: string;
}

export function renderAutomationForm(props: {
  state: FormState;
  onChange: (field: keyof FormState, value: any) => void;
  onSubmit: () => void;
}) {
  const { state, onChange, onSubmit } = props;

  return html`
    <form
      @submit=${(e: Event) => {
        e.preventDefault();
        onSubmit();
      }}
    >
      <input
        type="text"
        .value=${state.name}
        @input=${(e: Event) => onChange("name", (e.target as HTMLInputElement).value)}
        placeholder="Name"
      />

      <input
        type="checkbox"
        .checked=${state.subscribed}
        @change=${(e: Event) => onChange("subscribed", (e.target as HTMLInputElement).checked)}
      />

      <select
        .value=${state.category}
        @change=${(e: Event) => onChange("category", (e.target as HTMLSelectElement).value)}
      >
        <option value="general">General</option>
        <option value="news">News</option>
      </select>

      <button type="submit">Submit</button>
    </form>
  `;
}
```

### Form Validation Pattern

```typescript
export interface FormField<T> {
  value: T;
  error?: string;
  touched: boolean;
}

export interface AutomationFormState {
  name: FormField<string>;
  schedule: FormField<string>;
}

export function renderFormField(props: {
  field: FormField<string>;
  label: string;
  onChange: (value: string) => void;
}) {
  const { field, label, onChange } = props;

  return html`
    <div class="form-field">
      <label>${label}</label>
      <input
        type="text"
        .value=${field.value}
        @input=${(e: Event) => onChange((e.target as HTMLInputElement).value)}
        class=${field.error && field.touched ? "error" : ""}
      />
      ${field.error && field.touched
        ? html`<span class="error-message">${field.error}</span>`
        : nothing}
    </div>
  `;
}
```

---

## 11. Icons

### React Icons (Lucide)

```tsx
import { Check, ChevronDown, Play } from 'lucide-react';

<Check size={16} className="icon" />
<ChevronDown strokeWidth={2} />
<Play color="#4ade80" />
```

### Clawdbrain Icons (PREFERRED)

```typescript
import { icon, type IconName } from "../icons";

// Basic usage
${icon("check", { size: 16 })}
${icon("chevron-down")}
${icon("play", { class: "play-icon" })}

// With color
${icon("check", { size: 20, class: "text-ok" })}

// In buttons
<button>
  ${icon("edit", { size: 16 })}
  Edit
</button>
```

### Available Icon Names in Clawdbrain

From `ui/src/ui/icons.ts`:

- message-square, layout-dashboard, link, radio, file-text, clock
- zap, server, settings, bug, scroll-text, book-open
- chevron-down, chevron-right, chevron-left, chevrons-down, menu, x
- sun, moon, monitor, refresh-cw, maximize, brain, sparkles
- user, users, log-out, check, check-circle, alert-circle, info
- alert-triangle, plus, plus-circle, minus, search, filter
- more-vertical, edit, edit-2, trash, trash-2, copy, external-link
- mic, play, pause, stop, square, send, panel-left, panel-left-close
- history, download, folder, arrow-down-to-line, target, activity
- trending-up, layers, list, box, rotate-ccw, inbox, loader, circle

---

## 12. Toasts and Notifications

### React Toast (Typical Pattern)

```tsx
import { toast } from "sonner";

toast.success("Automation created!");
toast.error("Failed to create automation");
toast("Default message");
```

### Clawdbrain Toast (PREFERRED)

```typescript
import { toast } from "../components/toast";

// Basic usage
toast.success("Automation created!");
toast.error("Failed to create automation");
toast.warning("Configuration incomplete");
toast.info("Sync in progress");

// With title
toast.success("Sync complete", "All 12 conflicts resolved");

// Manual dismiss
const id = toast.info("Processing...");
// ... later
toast.dismiss(id);

// Promise tracking
await toast.promise(executeAutomation(), {
  loading: "Running automation...",
  success: "Automation complete!",
  error: (err) => `Failed: ${err.message}`,
});
```

### Toast Types

```typescript
export type ToastType = "success" | "error" | "warning" | "info";

export interface ToastOptions {
  type?: ToastType;
  title?: string;
  message: string;
  duration?: number; // ms, 0 = manual dismiss only
  dismissible?: boolean;
}
```

---

## 13. Modals and Dialogs

### React Modal Pattern

```tsx
const [isOpen, setIsOpen] = useState(false);

return (
  <>
    <button onClick={() => setIsOpen(true)}>Open</button>
    {isOpen && (
      <div className="modal-overlay" onClick={() => setIsOpen(false)}>
        <div className="modal" onClick={(e) => e.stopPropagation()}>
          <h2>Modal Title</h2>
          <button onClick={() => setIsOpen(false)}>Close</button>
        </div>
      </div>
    )}
  </>
);
```

### Clawdbrain Confirm Dialog Pattern

```typescript
import { showDangerConfirmDialog } from "../components/confirm-dialog";

const confirmed = await showDangerConfirmDialog(
  "Delete Automation",
  `Delete automation "${name}"? This action cannot be undone.`,
  "Delete",
);

if (!confirmed) {
  return; // User cancelled
}

// Proceed with deletion
```

### Custom Modal Pattern

```typescript
export interface ModalState {
  open: boolean;
  title: string;
  content: TemplateResult | null;
}

export function renderModal(props: { state: ModalState; onClose: () => void }) {
  const { state, onClose } = props;

  if (!state.open) return nothing;

  return html`
    <div class="modal-overlay" @click=${onClose}>
      <div class="modal" @click=${(e: Event) => e.stopPropagation()}>
        <div class="modal-header">
          <h2>${state.title}</h2>
          <button class="modal-close" @click=${onClose}>${icon("x")}</button>
        </div>
        <div class="modal-content">${state.content}</div>
      </div>
    </div>
  `;
}
```

---

## 14. Navigation and Routing

### React Router

```tsx
import { useNavigate, Link } from "react-router-dom";

const navigate = useNavigate();
navigate("/automations/123");

<Link to="/automations/123">View Details</Link>;
```

### Clawdbrain Navigation (PREFERRED)

```typescript
import {
  type Tab,
  hrefForTab,
  hashForTab,
  buildHashRoute
} from "../navigation";

// Navigate to a tab
window.location.hash = hashForTab("automations");
// Or: window.location.href = hrefForTab("automations");

// With query parameters
const hash = buildHashRoute("/automations", new URLSearchParams({
  id: "automation-123",
  view: "details"
}));
window.location.hash = hash;

// In template
<a href="${hrefForTab('automations')}">Automations</a>
<a href="${hrefForTab('automations', { id: '123' })}">View Details</a>
```

### Tab Groups

From `navigation.ts`:

```typescript
export const TAB_GROUPS = [
  { label: "Chat", tabs: ["chat"] },
  {
    label: "Control",
    tabs: ["overview", "agents", "channels", "instances", "sessions", "cron", "overseer"],
  },
  { label: "Agent", tabs: ["skills", "nodes"] },
  { label: "Settings", tabs: ["config", "debug", "logs"] },
] as const;

// "Automations" should be added to the "Control" group
```

---

## 15. Common Translation Patterns

### Pattern 1: Component with State and Actions

#### React

```tsx
export function AutomationCard({ automation }: { automation: Automation }) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isRunning, setIsRunning] = useState(false);

  const handleRun = async () => {
    setIsRunning(true);
    try {
      await runAutomation(automation.id);
      toast.success("Automation started");
    } catch (err) {
      toast.error("Failed to start");
    } finally {
      setIsRunning(false);
    }
  };

  return (
    <div className={`card ${isExpanded ? "expanded" : ""}`}>
      <h3>{automation.name}</h3>
      <button onClick={() => setIsExpanded(!isExpanded)} disabled={isRunning}>
        {isRunning ? "Running..." : "Run Now"}
      </button>
    </div>
  );
}
```

#### Lit (Render Function + Controller)

```typescript
// Controller
export interface AutomationsState {
  expandedIds: Set<string>;
  runningIds: Set<string>;
}

export async function runAutomation(state: AutomationsState, id: string) {
  state.runningIds.add(id);
  try {
    await client.request("automations.run", { id });
    toast.success("Automation started");
  } catch (err) {
    toast.error("Failed to start");
  } finally {
    state.runningIds.delete(id);
  }
}

// Render function
export function renderAutomationCard(props: {
  automation: Automation;
  state: AutomationsState;
  onToggleExpand: (id: string) => void;
  onRun: (id: string) => Promise<void>;
}) {
  const { automation, state, onToggleExpand, onRun } = props;
  const isExpanded = state.expandedIds.has(automation.id);
  const isRunning = state.runningIds.has(automation.id);

  return html`
    <div class="card ${isExpanded ? "expanded" : ""}">
      <h3>${automation.name}</h3>
      <button @click=${() => onToggleExpand(automation.id)} ?disabled=${isRunning}>
        ${isRunning ? "Running..." : "Run Now"}
      </button>
    </div>
  `;
}
```

### Pattern 2: List with Filter and Search

#### React

```tsx
export function AutomationList({ automations }: { automations: Automation[] }) {
  const [search, setSearch] = useState("");
  const [filter, setFilter] = useState<"all" | "active" | "suspended">("all");

  const filtered = automations
    .filter((a) => filter === "all" || a.status === filter)
    .filter((a) => a.name.toLowerCase().includes(search.toLowerCase()));

  return (
    <div>
      <input value={search} onChange={(e) => setSearch(e.target.value)} placeholder="Search..." />
      <select value={filter} onChange={(e) => setFilter(e.target.value as any)}>
        <option value="all">All</option>
        <option value="active">Active</option>
        <option value="suspended">Suspended</option>
      </select>
      {filtered.map((a) => (
        <AutomationCard key={a.id} automation={a} />
      ))}
    </div>
  );
}
```

#### Lit

```typescript
export interface ListState {
  search: string;
  filter: "all" | "active" | "suspended";
}

export function filterAutomations(automations: Automation[], state: ListState): Automation[] {
  return automations
    .filter((a) => state.filter === "all" || a.status === state.filter)
    .filter((a) => a.name.toLowerCase().includes(state.search.toLowerCase()));
}

export function renderAutomationList(props: {
  automations: Automation[];
  state: ListState;
  onSearchChange: (value: string) => void;
  onFilterChange: (value: ListState["filter"]) => void;
}) {
  const { automations, state, onSearchChange, onFilterChange } = props;
  const filtered = filterAutomations(automations, state);

  return html`
    <div class="automation-list">
      <div class="automation-list__filters">
        <input
          type="text"
          .value=${state.search}
          @input=${(e: Event) => onSearchChange((e.target as HTMLInputElement).value)}
          placeholder="Search..."
        />
        <select
          .value=${state.filter}
          @change=${(e: Event) => onFilterChange((e.target as HTMLSelectElement).value as any)}
        >
          <option value="all">All</option>
          <option value="active">Active</option>
          <option value="suspended">Suspended</option>
        </select>
      </div>
      <div class="automation-list__items">
        ${filtered.map((a) => renderAutomationCard({ automation: a }))}
      </div>
    </div>
  `;
}
```

### Pattern 3: Multi-Step Wizard

#### React

```tsx
export function AutomationWizard() {
  const [step, setStep] = useState(1);
  const [data, setData] = useState({
    name: "",
    schedule: "",
    repos: {},
    aiSettings: {},
  });

  const nextStep = () => setStep((s) => s + 1);
  const prevStep = () => setStep((s) => s - 1);

  return (
    <div className="wizard">
      <div className="wizard-steps">
        {[1, 2, 3, 4, 5, 6].map((s) => (
          <div key={s} className={s <= step ? "active" : ""}>
            {s}
          </div>
        ))}
      </div>
      {step === 1 && <BasicInfoStep data={data} onChange={setData} />}
      {step === 2 && <ScheduleStep data={data} onChange={setData} />}
      {/* ... */}
      <div className="wizard-actions">
        {step > 1 && <button onClick={prevStep}>Back</button>}
        {step < 6 && <button onClick={nextStep}>Next</button>}
        {step === 6 && <button onClick={handleSubmit}>Create</button>}
      </div>
    </div>
  );
}
```

#### Lit

```typescript
export interface WizardState {
  currentStep: number;
  data: {
    name: string;
    schedule: string;
    repos: Record<string, unknown>;
    aiSettings: Record<string, unknown>;
  };
}

export function renderAutomationWizard(props: {
  state: WizardState;
  onNextStep: () => void;
  onPrevStep: () => void;
  onDataChange: (data: Partial<WizardState["data"]>) => void;
  onSubmit: () => void;
}) {
  const { state, onNextStep, onPrevStep, onDataChange, onSubmit } = props;
  const totalSteps = 6;

  return html`
    <div class="wizard">
      <div class="wizard-steps">
        ${Array.from({ length: totalSteps }, (_, i) => i + 1).map((step) => {
          const isActive = step <= state.currentStep;
          const isCurrent = step === state.currentStep;
          return html`
            <div
              class="wizard-step ${isActive ? "active" : ""} ${isCurrent ? "current" : ""}"
              data-step="${step}"
            >
              ${step}
            </div>
          `;
        })}
      </div>

      <div class="wizard-content">
        ${state.currentStep === 1
          ? renderBasicInfoStep({
              data: state.data,
              onChange: onDataChange,
            })
          : nothing}
        ${state.currentStep === 2
          ? renderScheduleStep({
              data: state.data,
              onChange: onDataChange,
            })
          : nothing}
        ${/* ... other steps */ nothing}
      </div>

      <div class="wizard-actions">
        ${state.currentStep > 1 ? html`<button @click=${onPrevStep}>Back</button>` : nothing}
        ${state.currentStep < totalSteps
          ? html`<button @click=${onNextStep}>Next</button>`
          : nothing}
        ${state.currentStep === totalSteps
          ? html`<button @click=${onSubmit}>Create Automation</button>`
          : nothing}
      </div>
    </div>
  `;
}
```

---

## 16. Clawdbrain-Specific Patterns

### Pattern: Controller + State + Render Functions

This is the PRIMARY pattern used in Clawdbrain UI code.

#### File Structure

```
ui/src/ui/controllers/automations.ts  # State + business logic
ui/src/ui/views/automations.ts        # Render functions
ui/src/ui/app.ts                      # Main app that wires everything together
```

#### Controller Example

```typescript
// ui/src/ui/controllers/automations.ts
import type { GatewayBrowserClient } from "../gateway";
import { toast } from "../components/toast";

export type Automation = {
  id: string;
  name: string;
  description?: string;
  type: string;
  enabled: boolean;
  schedule: Schedule;
  config: Record<string, unknown>;
};

export type AutomationsState = {
  client: GatewayBrowserClient | null;
  connected: boolean;
  loading: boolean;
  automations: Automation[];
  error: string | null;
  selectedId: string | null;
};

export async function loadAutomations(state: AutomationsState) {
  if (!state.client || !state.connected) return;
  if (state.loading) return;

  state.loading = true;
  state.error = null;
  try {
    const res = await state.client.request("automations.list", {}, { timeoutMs: 10_000 });
    state.automations = res.automations ?? [];
  } catch (err) {
    state.error = String(err);
    toast.error("Failed to load automations");
  } finally {
    state.loading = false;
  }
}

export async function createAutomation(state: AutomationsState, config: Omit<Automation, "id">) {
  if (!state.client || !state.connected) return;

  try {
    await state.client.request("automations.create", config);
    await loadAutomations(state);
    toast.success("Automation created");
  } catch (err) {
    state.error = String(err);
    toast.error("Failed to create automation");
  }
}

export async function deleteAutomation(state: AutomationsState, id: string) {
  if (!state.client || !state.connected) return;

  try {
    await state.client.request("automations.delete", { id });
    await loadAutomations(state);
    toast.success("Automation deleted");
  } catch (err) {
    state.error = String(err);
    toast.error("Failed to delete automation");
  }
}
```

#### View/Render Functions Example

```typescript
// ui/src/ui/views/automations.ts
import { html, nothing } from "lit";
import { icon } from "../icons";
import type { Automation } from "../controllers/automations";

export function renderAutomationsList(props: {
  automations: Automation[];
  onSelect: (id: string) => void;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
  onRun: (id: string) => void;
}) {
  const { automations, onSelect, onEdit, onDelete, onRun } = props;

  if (automations.length === 0) {
    return html`
      <div class="empty-state">
        ${icon("inbox", { size: 48, class: "text-muted" })}
        <h3>No automations yet</h3>
        <p>Create your first automation to get started.</p>
      </div>
    `;
  }

  return html`
    <div class="automations-grid">
      ${automations.map((automation) =>
        renderAutomationCard({
          automation,
          onSelect,
          onEdit,
          onDelete,
          onRun,
        }),
      )}
    </div>
  `;
}

export function renderAutomationCard(props: {
  automation: Automation;
  onSelect: (id: string) => void;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
  onRun: (id: string) => void;
}) {
  const { automation, onSelect, onEdit, onDelete, onRun } = props;

  const statusClass = automation.enabled ? "active" : "suspended";
  const statusIcon = automation.enabled ? "check-circle" : "pause-circle";

  return html`
    <div class="automation-card" data-status="${statusClass}">
      <div class="automation-card__header">
        <div class="automation-card__title">
          <h3>${automation.name}</h3>
          ${automation.description ? html`<p>${automation.description}</p>` : nothing}
        </div>
        <div class="automation-card__status">
          ${icon(statusIcon, { size: 16, class: `status-icon status-icon--${statusClass}` })}
          <span class="status-text">${automation.enabled ? "Active" : "Suspended"}</span>
        </div>
      </div>

      <div class="automation-card__meta">
        <span class="type-badge">${automation.type}</span>
        <span class="schedule-badge">${formatSchedule(automation.schedule)}</span>
      </div>

      <div class="automation-card__actions">
        <button
          class="btn btn-primary"
          @click=${() => onRun(automation.id)}
          ?disabled=${!automation.enabled}
        >
          ${icon("play", { size: 14 })} Run Now
        </button>
        <button class="btn btn-secondary" @click=${() => onEdit(automation.id)}>
          ${icon("edit", { size: 14 })} Edit
        </button>
        <button class="btn btn-danger" @click=${() => onDelete(automation.id)}>
          ${icon("trash", { size: 14 })}
        </button>
      </div>
    </div>
  `;
}
```

### Pattern: Command Palette Integration

#### React

```tsx
import { useCommandPalette } from "@/hooks/useCommandPalette";

function AutomationsView() {
  const { registerCommands } = useCommandPalette();

  useEffect(() => {
    return registerCommands([
      {
        id: "create-automation",
        label: "Create Automation",
        icon: "plus",
        action: () => setShowCreateModal(true),
      },
      {
        id: "refresh-automations",
        label: "Refresh Automations",
        icon: "refresh-cw",
        action: () => refetch(),
      },
    ]);
  }, [registerCommands]);

  return <div>...</div>;
}
```

#### Lit/Clawdbrain

```typescript
// In controller or view setup
import type { Command } from "../components/command-palette";

export function createAutomationsCommands(actions: {
  onCreate: () => void;
  onRefresh: () => void;
  onRun: (id: string) => void;
}): Command[] {
  return [
    {
      id: "automation-create",
      label: "Create Automation",
      icon: "plus",
      category: "Automations",
      action: actions.onCreate,
    },
    {
      id: "automation-refresh",
      label: "Refresh Automations",
      icon: "refresh-cw",
      category: "Automations",
      action: actions.onRefresh,
    },
  ];
}

// In main app or command palette setup, these commands are merged
// with the default commands and context-specific commands
```

---

## 17. Complete Translation Example

### React Component (Magic MCP Output)

```tsx
import { useState } from "react";
import { motion } from "framer-motion";
import { Check, ChevronDown, Play, Trash2, Settings } from "lucide-react";

interface Automation {
  id: string;
  name: string;
  description: string;
  status: "active" | "suspended" | "error";
  lastRun: string;
  nextRun: string;
}

export function AutomationCard({ automation }: { automation: Automation }) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isRunning, setIsRunning] = useState(false);

  const handleRun = async () => {
    setIsRunning(true);
    try {
      await fetch(`/api/automations/${automation.id}/run`, { method: "POST" });
      toast.success("Automation started");
    } catch (err) {
      toast.error("Failed to start automation");
    } finally {
      setIsRunning(false);
    }
  };

  const statusColors = {
    active: "bg-green-100 text-green-800",
    suspended: "bg-yellow-100 text-yellow-800",
    error: "bg-red-100 text-red-800",
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-white rounded-lg border border-gray-200 p-4"
    >
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <div className="flex items-center gap-2">
            <h3 className="text-lg font-semibold">{automation.name}</h3>
            <span className={`px-2 py-1 rounded text-xs ${statusColors[automation.status]}`}>
              {automation.status}
            </span>
          </div>
          <p className="text-gray-600 mt-1">{automation.description}</p>
        </div>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="p-2 hover:bg-gray-100 rounded"
        >
          <ChevronDown className={`transition-transform ${isExpanded ? "rotate-180" : ""}`} />
        </button>
      </div>

      {isExpanded && (
        <motion.div
          initial={{ height: 0 }}
          animate={{ height: "auto" }}
          className="mt-4 pt-4 border-t"
        >
          <div className="grid grid-cols-2 gap-4 text-sm">
            <div>
              <span className="text-gray-500">Last Run:</span>
              <span className="ml-2">{automation.lastRun}</span>
            </div>
            <div>
              <span className="text-gray-500">Next Run:</span>
              <span className="ml-2">{automation.nextRun}</span>
            </div>
          </div>

          <div className="flex gap-2 mt-4">
            <button
              onClick={handleRun}
              disabled={isRunning}
              className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              <Play size={16} />
              {isRunning ? "Running..." : "Run Now"}
            </button>
            <button className="p-2 hover:bg-gray-100 rounded">
              <Settings size={16} />
            </button>
            <button className="p-2 hover:bg-gray-100 rounded text-red-600">
              <Trash2 size={16} />
            </button>
          </div>
        </motion.div>
      )}
    </motion.div>
  );
}
```

### Lit Translation (Clawdbrain Pattern)

```typescript
// ui/src/ui/views/automations.ts
import { html, nothing } from "lit";
import { icon, type IconName } from "../icons";

export interface Automation {
  id: string;
  name: string;
  description: string;
  status: "active" | "suspended" | "error";
  lastRun: string;
  nextRun: string;
}

export interface AutomationCardProps {
  automation: Automation;
  isExpanded: boolean;
  isRunning: boolean;
  onToggleExpand: (id: string) => void;
  onRun: (id: string) => Promise<void>;
  onSettings: (id: string) => void;
  onDelete: (id: string) => void;
}

export function renderAutomationCard(props: AutomationCardProps) {
  const { automation, isExpanded, isRunning, onToggleExpand, onRun, onSettings, onDelete } = props;

  const statusConfig: Record<
    Automation["status"],
    { class: string; icon: IconName; label: string }
  > = {
    active: { class: "status-active", icon: "check-circle", label: "Active" },
    suspended: { class: "status-suspended", icon: "pause", label: "Suspended" },
    error: { class: "status-error", icon: "alert-circle", label: "Error" },
  };

  const status = statusConfig[automation.status];

  return html`
    <div class="automation-card" data-id="${automation.id}">
      <div class="automation-card__header">
        <div class="automation-card__info">
          <div class="automation-card__title-row">
            <h3 class="automation-card__name">${automation.name}</h3>
            <span class="status-badge ${status.class}">
              ${icon(status.icon, { size: 14 })} ${status.label}
            </span>
          </div>
          ${automation.description
            ? html`<p class="automation-card__description">${automation.description}</p>`
            : nothing}
        </div>
        <button
          class="automation-card__expand-btn"
          @click=${() => onToggleExpand(automation.id)}
          aria-label="Toggle details"
          aria-expanded=${isExpanded}
        >
          ${icon("chevron-down", {
            size: 20,
            class: isExpanded ? "rotate-180" : "",
          })}
        </button>
      </div>

      ${isExpanded
        ? html`
            <div class="automation-card__details">
              <div class="automation-card__meta">
                <div class="meta-item">
                  <span class="meta-label">Last Run:</span>
                  <span class="meta-value">${automation.lastRun}</span>
                </div>
                <div class="meta-item">
                  <span class="meta-label">Next Run:</span>
                  <span class="meta-value">${automation.nextRun}</span>
                </div>
              </div>

              <div class="automation-card__actions">
                <button
                  class="btn btn-primary"
                  @click=${() => onRun(automation.id)}
                  ?disabled=${isRunning || automation.status === "suspended"}
                >
                  ${icon("play", { size: 16 })} ${isRunning ? "Running..." : "Run Now"}
                </button>
                <button
                  class="btn btn-secondary"
                  @click=${() => onSettings(automation.id)}
                  title="Settings"
                >
                  ${icon("settings", { size: 16 })}
                </button>
                <button
                  class="btn btn-danger"
                  @click=${() => onDelete(automation.id)}
                  title="Delete"
                >
                  ${icon("trash", { size: 16 })}
                </button>
              </div>
            </div>
          `
        : nothing}
    </div>
  `;
}
```

### Corresponding Controller

```typescript
// ui/src/ui/controllers/automations.ts
import type { GatewayBrowserClient } from "../gateway";
import { toast } from "../components/toast";
import { showDangerConfirmDialog } from "../components/confirm-dialog";
import type { Automation } from "../views/automations";

export type AutomationsState = {
  client: GatewayBrowserClient | null;
  connected: boolean;
  loading: boolean;
  automations: Automation[];
  expandedIds: Set<string>;
  runningIds: Set<string>;
  error: string | null;
};

export async function loadAutomations(state: AutomationsState) {
  if (!state.client || !state.connected || state.loading) return;

  state.loading = true;
  state.error = null;
  try {
    const res = await state.client.request("automations.list");
    state.automations = res.automations ?? [];
  } catch (err) {
    state.error = String(err);
    toast.error("Failed to load automations");
  } finally {
    state.loading = false;
  }
}

export function toggleExpand(state: AutomationsState, id: string) {
  if (state.expandedIds.has(id)) {
    state.expandedIds.delete(id);
  } else {
    state.expandedIds.add(id);
  }
  // Trigger re-render in actual implementation
}

export async function runAutomation(state: AutomationsState, id: string) {
  if (!state.client || !state.connected) return;

  state.runningIds.add(id);
  try {
    await state.client.request("automations.run", { id });
    toast.success("Automation started");
  } catch (err) {
    state.error = String(err);
    toast.error("Failed to start automation");
  } finally {
    state.runningIds.delete(id);
  }
}

export async function deleteAutomation(state: AutomationsState, id: string) {
  const automation = state.automations.find((a) => a.id === id);
  if (!automation) return;

  const confirmed = await showDangerConfirmDialog(
    "Delete Automation",
    `Delete automation "${automation.name}"? This action cannot be undone.`,
    "Delete",
  );

  if (!confirmed) return;

  if (!state.client || !state.connected) return;

  try {
    await state.client.request("automations.delete", { id });
    await loadAutomations(state);
    toast.success("Automation deleted");
  } catch (err) {
    state.error = String(err);
    toast.error("Failed to delete automation");
  }
}

export function openSettings(state: AutomationsState, id: string) {
  // Navigate to settings view or open modal
  window.location.hash = `#automations?id=${id}&view=settings`;
}
```

### CSS (Tailwind + Custom Properties)

```css
/* For ui/src/ui/styles/automations.css or in component <style> tag */
.automation-card {
  background: var(--panel-strong);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 1rem;
  transition: box-shadow 0.2s ease-out;
}

.automation-card:hover {
  box-shadow: var(--shadow-elevated-lg);
}

.automation-card__header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 1rem;
}

.automation-card__title-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.automation-card__name {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text);
  margin: 0;
}

.status-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.5rem;
  border-radius: var(--radius-sm);
  font-size: 0.75rem;
  font-weight: 500;
}

.status-active {
  background: var(--ok-bg, rgba(34, 197, 94, 0.1));
  color: var(--ok);
}

.status-suspended {
  background: var(--warn-bg, rgba(234, 179, 8, 0.1));
  color: var(--warn);
}

.status-error {
  background: var(--danger-bg, rgba(239, 68, 68, 0.1));
  color: var(--danger);
}

.automation-card__expand-btn {
  padding: 0.5rem;
  background: transparent;
  border: none;
  border-radius: var(--radius-sm);
  color: var(--muted);
  cursor: pointer;
  transition: all 0.15s ease-out;
}

.automation-card__expand-btn:hover {
  background: var(--bg-overlay);
  color: var(--text);
}

.automation-card__expand-btn svg {
  transition: transform 0.2s ease-out;
}

.automation-card__expand-btn svg.rotate-180 {
  transform: rotate(180deg);
}

.automation-card__details {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border);
}

.automation-card__meta {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
  margin-bottom: 1rem;
}

.meta-item {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.meta-label {
  font-size: 0.75rem;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.meta-value {
  font-size: 0.875rem;
  color: var(--text);
}

.automation-card__actions {
  display: flex;
  gap: 0.5rem;
}

.btn {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease-out;
  border: none;
}

.btn-primary {
  background: var(--accent);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  opacity: 0.9;
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-secondary {
  background: var(--bg-overlay);
  color: var(--text);
}

.btn-secondary:hover {
  background: var(--border);
}

.btn-danger {
  background: transparent;
  color: var(--danger);
}

.btn-danger:hover {
  background: var(--danger-bg, rgba(239, 68, 68, 0.1));
}
```

---

## Quick Reference: React â†’ Lit Cheat Sheet

| Concept          | React                                  | Lit (Clawdbrain Pattern)                                 |
| ---------------- | -------------------------------------- | -------------------------------------------------------- |
| **Component**    | `function Component() { ... }`         | `function renderComponent(props: Props) { ... }`         |
| **State**        | `const [x, setX] = useState(0)`        | Controller: `state.x = 0`                                |
| **Effect**       | `useEffect(() => { ... }, [])`         | Controller function: `async function init() { ... }`     |
| **Props**        | Destructured in function args          | Interface + destructured: `const { x, y } = props`       |
| **Events**       | `onClick={handler}`                    | `@click=${handler}`                                      |
| **Input value**  | `value={val}`                          | `.value=${val}` (property binding)                       |
| **Conditionals** | `{cond && <div />}`                    | `cond ? html`<div />` : nothing`                         |
| **Lists**        | `{items.map(i => <div key={i.id} />)}` | `${items.map(i => html`<div data-id="${i.id}"></div>`)}` |
| **Icons**        | `<Check size={16} />`                  | `${icon("check", { size: 16 })}`                         |
| **Toasts**       | `toast.success("msg")`                 | `toast.success("msg")` (same!)                           |
| **Refs**         | `const ref = useRef()`                 | `this.shadowRoot.querySelector()` (class) or direct DOM  |
| **CSS**          | `className="flex gap-2"`               | `class="flex gap-2"`                                     |
| **Styles**       | `style={{ color: 'red' }}`             | `style="color: red"`                                     |
| **Fragments**    | `<><div /><div /></>`                  | Not needed - just return multiple templates              |
| **Template**     | JSX                                    | `html`<div>...</div>``                                   |

---

## Common Gotchas

1. **Attribute vs Property Binding**
   - âŒ `value="${val}"` (sets attribute, doesn't work for inputs)
   - âœ… `.value=${val}` (sets property, correct for inputs)

2. **Event Object**
   - React: Synthetic event with `.target` already typed
   - Lit: Native event, need casting: `(e.target as HTMLInputElement).value`

3. **Boolean Attributes**
   - React: `disabled={cond}`
   - Lit: `?disabled=${cond}` or `disabled=${cond ? 'true' : nothing}`

4. **Class vs ClassName**
   - React: `className`
   - Lit: `class`

5. **Nothing vs Null**
   - React: `return null` or `{null}`
   - Lit: `return nothing` or `${nothing}`

6. **Style Objects**
   - React: `style={{ display: 'flex' }}`
   - Lit: `style="display: flex"` or use CSS classes

7. **Keys**
   - React: `key={item.id}`
   - Lit: `data-key="${item.id}"` (no built-in key prop, use data attributes)

---

## Checklist for Translation

When translating a React component to Lit:

- [ ] Convert function component to render function with props interface
- [ ] Replace JSX with `html` tag function templates
- [ ] Convert `onClick` to `@click`, `onChange` to `@input`/`@change`
- [ ] Replace `{cond && <x />}` with `cond ? html`<x />` : nothing`
- [ ] Use `.value=` for input values instead of `value=`
- [ ] Replace `className` with `class`
- [ ] Convert React icons (lucide-react) to Clawdbrain `icon()` function
- [ ] Extract state management to controller if complex
- [ ] Use Tailwind classes directly (no CSS modules needed)
- [ ] Add `data-` attributes instead of `key` props
- [ ] Use property binding `.propName=${}` for object/complex props
- [ ] Import `html` and `nothing` from "lit"
- [ ] Import `icon` from "../icons"
- [ ] Use `toast` from "../components/toast" for notifications
- [ ] Use Clawdbrain CSS custom properties for theming
- [ ] Follow BEM-ish naming: `block__element--modifier`

---

## Summary

The Clawdbrain UI uses a **controller + render function** pattern that differs from both pure React and pure Lit class-based components. When translating:

1. **Keep React components as reference** for UI structure and behavior
2. **Convert to render functions** that accept props and return Lit templates
3. **Extract state and logic** into controller classes/modules
4. **Use Clawdbrain's existing utilities**: `icon()`, `toast()`, navigation functions
5. **Follow existing patterns** from `/ui/src/ui/controllers/` and `/ui/src/ui/views/`

This approach maintains consistency with the Clawdbrain codebase while providing a clean separation between state management and rendering.
