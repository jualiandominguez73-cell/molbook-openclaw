diff --git a/src/agents/tools/sessions-spawn-tool.ts b/src/agents/tools/sessions-spawn-tool.ts
index c9bf851f3..b6d27f6df 100644
--- a/src/agents/tools/sessions-spawn-tool.ts
+++ b/src/agents/tools/sessions-spawn-tool.ts
@@ -235,6 +235,8 @@ export function createSessionsSpawnTool(opts?: {
             timeout: runTimeoutSeconds > 0 ? runTimeoutSeconds : undefined,
             label: label || undefined,
             spawnedBy: spawnedByKey,
+            threadId: opts?.agentThreadId != null ? String(opts.agentThreadId) : undefined,
+            accountId: opts?.agentAccountId ?? undefined,
             groupId: opts?.agentGroupId ?? undefined,
             groupChannel: opts?.agentGroupChannel ?? undefined,
             groupSpace: opts?.agentGroupSpace ?? undefined,
diff --git a/src/auto-reply/commands-registry.data.ts b/src/auto-reply/commands-registry.data.ts
index e9395347e..d6b21b8eb 100644
--- a/src/auto-reply/commands-registry.data.ts
+++ b/src/auto-reply/commands-registry.data.ts
@@ -130,6 +130,13 @@ let cachedNativeRegistry: ReturnType<typeof getActivePluginRegistry> | null = nu
 
 function buildChatCommands(): ChatCommandDefinition[] {
   const commands: ChatCommandDefinition[] = [
+    defineChatCommand({
+      key: "stop",
+      nativeName: "stop",
+      description: "Stop the current run.",
+      textAlias: "/stop",
+      category: "session",
+    }),
     defineChatCommand({
       key: "help",
       nativeName: "help",
@@ -345,13 +352,6 @@ function buildChatCommands(): ChatCommandDefinition[] {
       ],
       argsMenu: "auto",
     }),
-    defineChatCommand({
-      key: "stop",
-      nativeName: "stop",
-      description: "Stop the current run.",
-      textAlias: "/stop",
-      category: "session",
-    }),
     defineChatCommand({
       key: "restart",
       nativeName: "restart",
diff --git a/src/infra/outbound/message-action-runner.threading.test.ts b/src/infra/outbound/message-action-runner.threading.test.ts
index 0a6ca44e9..ecbc168ba 100644
--- a/src/infra/outbound/message-action-runner.threading.test.ts
+++ b/src/infra/outbound/message-action-runner.threading.test.ts
@@ -4,6 +4,7 @@ import type { OpenClawConfig } from "../../config/config.js";
 import { setActivePluginRegistry } from "../../plugins/runtime.js";
 import { createTestRegistry } from "../../test-utils/channel-plugins.js";
 import { slackPlugin } from "../../../extensions/slack/src/channel.js";
+import { telegramPlugin } from "../../../extensions/telegram/src/channel.js";
 
 const mocks = vi.hoisted(() => ({
   executeSendAction: vi.fn(),
@@ -116,3 +117,111 @@ describe("runMessageAction Slack threading", () => {
     expect(call?.ctx?.mirror?.sessionKey).toBe("agent:main:slack:channel:c123:thread:333.444");
   });
 });
+
+const telegramConfig = {
+  channels: {
+    telegram: {
+      enabled: true,
+      botToken: "test:token",
+    },
+  },
+} as MoltbotConfig;
+
+describe("runMessageAction thread id injection from toolContext", () => {
+  beforeEach(async () => {
+    const { createPluginRuntime } = await import("../../plugins/runtime/index.js");
+    const { setTelegramRuntime } = await import("../../../extensions/telegram/src/runtime.js");
+    const runtime = createPluginRuntime();
+    setTelegramRuntime(runtime);
+    setActivePluginRegistry(
+      createTestRegistry([
+        {
+          pluginId: "telegram",
+          source: "test",
+          plugin: telegramPlugin,
+        },
+      ]),
+    );
+  });
+
+  afterEach(() => {
+    setActivePluginRegistry(createTestRegistry([]));
+    mocks.executeSendAction.mockReset();
+    mocks.recordSessionMetaFromInbound.mockReset();
+  });
+
+  it("injects toolContext.currentThreadTs into params.threadId when not explicitly set", async () => {
+    mocks.executeSendAction.mockResolvedValue({
+      handledBy: "plugin",
+      payload: { ok: true, messageId: "123", chatId: "63448508" },
+    });
+
+    await runMessageAction({
+      cfg: telegramConfig,
+      action: "send",
+      params: {
+        channel: "telegram",
+        target: "63448508",
+        message: "hello from topic",
+      },
+      toolContext: {
+        currentChannelId: "63448508",
+        currentChannelProvider: "telegram",
+        currentThreadTs: "994409",
+      },
+    });
+
+    const call = mocks.executeSendAction.mock.calls[0]?.[0];
+    expect(call?.ctx?.params?.threadId).toBe("994409");
+  });
+
+  it("does not override explicit threadId with toolContext", async () => {
+    mocks.executeSendAction.mockResolvedValue({
+      handledBy: "plugin",
+      payload: { ok: true, messageId: "124", chatId: "63448508" },
+    });
+
+    await runMessageAction({
+      cfg: telegramConfig,
+      action: "send",
+      params: {
+        channel: "telegram",
+        target: "63448508",
+        message: "explicit thread",
+        threadId: "12345",
+      },
+      toolContext: {
+        currentChannelId: "63448508",
+        currentChannelProvider: "telegram",
+        currentThreadTs: "994409",
+      },
+    });
+
+    const call = mocks.executeSendAction.mock.calls[0]?.[0];
+    expect(call?.ctx?.params?.threadId).toBe("12345");
+  });
+
+  it("does not inject threadId when toolContext has no currentThreadTs", async () => {
+    mocks.executeSendAction.mockResolvedValue({
+      handledBy: "plugin",
+      payload: { ok: true, messageId: "125", chatId: "63448508" },
+    });
+
+    await runMessageAction({
+      cfg: telegramConfig,
+      action: "send",
+      params: {
+        channel: "telegram",
+        target: "63448508",
+        message: "no thread context",
+      },
+      toolContext: {
+        currentChannelId: "63448508",
+        currentChannelProvider: "telegram",
+      },
+    });
+
+    const call = mocks.executeSendAction.mock.calls[0]?.[0];
+    expect(call?.ctx?.params?.threadId).toBeUndefined();
+  });
+});
diff --git a/src/infra/outbound/message-action-runner.ts b/src/infra/outbound/message-action-runner.ts
index 16718adf4..1e39f6c67 100644
--- a/src/infra/outbound/message-action-runner.ts
+++ b/src/infra/outbound/message-action-runner.ts
@@ -954,6 +954,13 @@ export async function runMessageAction(
     }
   }
 
+  // Inject thread id from session context when not explicitly provided.
+  // This ensures the message tool sends to the correct Telegram DM topic
+  // (or forum thread) instead of the General/root chat.
+  if (!params.threadId && input.toolContext?.currentThreadTs) {
+    params.threadId = input.toolContext.currentThreadTs;
+  }
+
   applyTargetToParams({ action, args: params });
   if (actionRequiresTarget(action)) {
     if (!actionHasTarget(action, params)) {
diff --git a/src/telegram/bot-message-context.dm-threads.test.ts b/src/telegram/bot-message-context.dm-threads.test.ts
index 6162e1cb1..1faef0ec9 100644
--- a/src/telegram/bot-message-context.dm-threads.test.ts
+++ b/src/telegram/bot-message-context.dm-threads.test.ts
@@ -56,6 +56,33 @@ describe("buildTelegramMessageContext dm thread sessions", () => {
     expect(ctx?.ctxPayload?.SessionKey).toBe("agent:main:main:thread:42");
   });
 
+  it("sets ThreadLabel for dm topics for display in Sessions tab", async () => {
+    const ctx = await buildContext({
+      message_id: 1,
+      chat: { id: 1234, type: "private" },
+      date: 1700000000,
+      text: "hello",
+      message_thread_id: 42,
+      from: { id: 42, first_name: "Alice" },
+    });
+
+    expect(ctx).not.toBeNull();
+    expect(ctx?.ctxPayload?.ThreadLabel).toBe("Thread: 42");
+  });
+
+  it("does not set ThreadLabel for dm without thread id", async () => {
+    const ctx = await buildContext({
+      message_id: 1,
+      chat: { id: 1234, type: "private" },
+      date: 1700000000,
+      text: "hello",
+      from: { id: 42, first_name: "Alice" },
+    });
+
+    expect(ctx).not.toBeNull();
+    expect(ctx?.ctxPayload?.ThreadLabel).toBeUndefined();
+  });
+
   it("keeps legacy dm session key when no thread id", async () => {
     const ctx = await buildContext({
       message_id: 2,
diff --git a/src/telegram/bot-message-context.ts b/src/telegram/bot-message-context.ts
index b86aa2d60..3dc22869b 100644
--- a/src/telegram/bot-message-context.ts
+++ b/src/telegram/bot-message-context.ts
@@ -163,6 +163,9 @@ export const buildTelegramMessageContext = async ({
     isForum,
     messageThreadId,
   });
+  // Effective thread ID for outbound delivery: groups use forum-resolved; DMs use raw messageThreadId
+  // (private chats never set is_forum=true per Telegram Bot API, so resolvedThreadId is always undefined for DMs)
+  const effectiveThreadId = isGroup ? resolvedThreadId : messageThreadId;
   const { groupConfig, topicConfig } = resolveTelegramGroupConfig(chatId, resolvedThreadId);
   const peerId = isGroup ? buildTelegramGroupPeerId(chatId, resolvedThreadId) : String(chatId);
   const route = resolveAgentRoute({
@@ -205,7 +208,8 @@ export const buildTelegramMessageContext = async ({
   const sendTyping = async () => {
     await withTelegramApiErrorLogging({
       operation: "sendChatAction",
-      fn: () => bot.api.sendChatAction(chatId, "typing", buildTypingThreadParams(resolvedThreadId)),
+      fn: () =>
+        bot.api.sendChatAction(chatId, "typing", buildTypingThreadParams(effectiveThreadId)),
     });
   };
 
@@ -214,7 +218,11 @@ export const buildTelegramMessageContext = async ({
       await withTelegramApiErrorLogging({
         operation: "sendChatAction",
         fn: () =>
-          bot.api.sendChatAction(chatId, "record_voice", buildTypingThreadParams(resolvedThreadId)),
+          bot.api.sendChatAction(
+            chatId,
+            "record_voice",
+            buildTypingThreadParams(effectiveThreadId),
+          ),
       });
     } catch (err) {
       logVerbose(`telegram record_voice cue failed for chat ${chatId}: ${String(err)}`);
@@ -621,6 +629,8 @@ export const buildTelegramMessageContext = async ({
     // For groups: use resolvedThreadId (forum topics only); for DMs: use raw messageThreadId
     MessageThreadId: isGroup ? resolvedThreadId : messageThreadId,
     IsForum: isForum,
+    // DM thread label for display in Sessions tab (e.g., "Sender Name (Thread: 42)")
+    ThreadLabel: !isGroup && messageThreadId != null ? `Thread: ${messageThreadId}` : undefined,
     // Originating channel for reply routing.
     OriginatingChannel: "telegram" as const,
     OriginatingTo: `telegram:${chatId}`,
@@ -671,7 +681,7 @@ export const buildTelegramMessageContext = async ({
     msg,
     chatId,
     isGroup,
-    resolvedThreadId,
+    resolvedThreadId: effectiveThreadId,
     isForum,
     historyKey,
     historyLimit,
diff --git a/ui/src/styles/components.css b/ui/src/styles/components.css
index 27dfe62d1..3b90f491b 100644
--- a/ui/src/styles/components.css
+++ b/ui/src/styles/components.css
@@ -1369,6 +1369,26 @@
   }
 }
 
+@media (max-width: 480px) {
+  .chat-compose__row {
+    flex-direction: column;
+  }
+
+  .chat-compose__actions {
+    gap: 4px;
+    justify-content: flex-end;
+  }
+
+  .chat-compose__actions .btn {
+    padding: 4px 8px;
+    font-size: 13px;
+  }
+
+  .chat-compose__actions .btn-kbd {
+    display: none;
+  }
+}
+
 /* ===========================================
    QR Code
    =========================================== */
diff --git a/ui/src/ui/app-lifecycle.ts b/ui/src/ui/app-lifecycle.ts
index cf5214250..40c6f0b1f 100644
--- a/ui/src/ui/app-lifecycle.ts
+++ b/ui/src/ui/app-lifecycle.ts
@@ -35,6 +35,8 @@ type LifecycleHost = {
 
 export function handleConnected(host: LifecycleHost) {
   host.basePath = inferBasePath();
+  // Apply URL settings FIRST so sessionKey is read before syncTabWithLocation
+  // overwrites it with the localStorage value
   applySettingsFromUrl(
     host as unknown as Parameters<typeof applySettingsFromUrl>[0],
   );
diff --git a/ui/src/ui/app-render.ts b/ui/src/ui/app-render.ts
index c3e102637..da3511c22 100644
--- a/ui/src/ui/app-render.ts
+++ b/ui/src/ui/app-render.ts
@@ -497,6 +497,23 @@ export function renderApp(state: AppViewState) {
               onSplitRatioChange: (ratio: number) => state.handleSplitRatioChange(ratio),
               assistantName: state.assistantName,
               assistantAvatar: state.assistantAvatar,
+              // Delete session (disabled for main session)
+              isMainSession:
+                state.sessionKey === "main" ||
+                parseAgentSessionKey(state.sessionKey)?.rest === "main",
+              onDelete: async () => {
+                const { deleteSession } = await import("./controllers/sessions");
+                await deleteSession(state as Parameters<typeof deleteSession>[0], state.sessionKey);
+                // Switch to main session after deletion
+                const mainKey = state.sessionsResult?.mainSessionKey ?? "main";
+                state.sessionKey = mainKey;
+                state.applySettings({
+                  ...state.settings,
+                  sessionKey: mainKey,
+                  lastActiveSessionKey: mainKey,
+                });
+                void loadChatHistory(state);
+              },
             })
           : nothing}
 
diff --git a/ui/src/ui/views/chat.ts b/ui/src/ui/views/chat.ts
index f5fb6e80b..d92ac2ce5 100644
--- a/ui/src/ui/views/chat.ts
+++ b/ui/src/ui/views/chat.ts
@@ -68,6 +68,9 @@ export type ChatProps = {
   onCloseSidebar?: () => void;
   onSplitRatioChange?: (ratio: number) => void;
   onChatScroll?: (event: Event) => void;
+  // Delete session
+  isMainSession?: boolean;
+  onDelete?: () => void;
 };
 
 const COMPACTION_TOAST_DURATION_MS = 5000;
@@ -361,6 +364,22 @@ export function renderChat(props: ChatProps) {
             >
               ${canAbort ? "Stop" : "New session"}
             </button>
+            ${props.onDelete
+              ? html`
+                  <button
+                    class="btn"
+                    ?disabled=${!props.connected || isBusy || props.isMainSession}
+                    @click=${() => {
+                      if (confirm(`Delete session "${props.sessionKey}"?`)) {
+                        props.onDelete!();
+                      }
+                    }}
+                    title=${props.isMainSession ? "Cannot delete main session" : "Delete this session"}
+                  >
+                    ðŸ—‘
+                  </button>
+                `
+              : nothing}
             <button
               class="btn primary"
               ?disabled=${!props.connected}
